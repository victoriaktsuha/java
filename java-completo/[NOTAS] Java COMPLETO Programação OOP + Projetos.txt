[NOTAS] Java COMPLETO Programação Orientada a Objetos + Projetos

Entendendo versões Java

SE (Standard Edition) - versão padrão
LTS (Long Term Support) - versão mais utilizada por empresas por ter suporte por muitos anos

versões LTS
8  - Mar 2014 ~ Dec 2030 *
11 - Sep 2018 ~ Not Available
17 - Sep 2021 ~ Sep 2029
21 - Sep 2023 ~ Sep 2031
25 - Sep 2025 ~ Sep 2033

Java
- é uma linguagem de programação
- plataforma de desenvolvimento e execução
	- bibliotecas API
	- ambientes de execução

Problemas resolvidos e motivo de seu sucesso:
- Ponteiros / gerenciamento  de memória - utilizava a linguagem C/C++ onde definia-se manualmente quais variáveis eram ponteiro e quais eram valor, fazendo com que essas linguagens fossem de baixo nível, gerando dificuldade ao programador e softwares mais sucetiveis a erros
- Portabilidade falha: reescrever parte do código ao mudar de SO; Embora existe padrão e compiladores para várias plataformas, o dev tinha que reescrever parte do código para as diversas plataformas/SO
- Utilização em dispositivos diversos
- Custo

Criada pela Sun Microsystems no meio da década de 1990

Adquirida pela Oracle Corporation em 2010

Aspectos notáveis
- Código compilado para bytecode e executado em máquina virtual (JVM)
- Portável, segura, robusta
- Roda em vários tipos de dispositivos
- Domina o mercado corporativo desde o fim do século 20
- Padrão Android por muitos anos (recentemente também utiliza-se Kotlin)

Edições
- Java ME - Java Micro Edition - dispositivos embarcados e móveis - IoT
- Java SE - Java Standard Edition - core - desktop e servidores
- Java EE - Java Enterprise Edition - aplicações corporativas

Plataforma Java SE
- JVM - Java Virtual Machine - necessário para executar sistemas Java

Compilação e interpretação
- Linguagens compiladas: C, C++ 
(rápidas e menos sucetivel a bugs por serem compiladas antes mas de difícil portabilidade)
- Linguagens interpretadas: PHP, JavaScript 
(tem um interpretador para cada sistema, são mais lentas pois a interpretação é feita JIT (just in time), ou seja, no momento que está sendo executado, mais sucetivel a bugs pois a tipagem é mais fraca e não há um compilador que garanta um código assertivo, mas tem boa portabilidade e manutenção)
- Linguagens pré-compiladas + VM: Java, C#
(une o melhor das duas modalidades anteriores: o código será pré-compilado garantindo a sintaxe correta e resultando no bytecode, compilado JIT e rodando em uma VM para o sistema operacional específico)

Estrutura de um aplicação Java
Java é uma linguagem orientada a objetos e a unidade lógica básica de um programa orientado a objetos é a classe. Todo código Java tem que estar dentro de classes. Após a classe, existe o contexto de package, sendo um agrupamento lógico de classes relacionadas. Exemplo de packages são entities (produto, cliente, pedido), services (email, pedido, log) e repositories(banco de dados)). Após o package, existe o conceito de módulo, introduzido a partir do Java 9, sendo um agrupamento lógico de pacotes relacionados. Exemplo de módulo seria um 'financeiro' contendo entidades, serviços e repositórios relacionados a pagamentos, contabilidade, etc. O 'runtime' ou 'build' representa um agrupamento físico de arquivos, sendo uma unidade que pode ser instalado para rodar em demais dispositivos. Após o modulo, tem a aplicação, sendo um agrupamento de módulos relacionados. Um exemplo seria um sistema de comercio eletronico, composto por vários módulos, que por sua vez, é composto por packages, que é composto por classes.
Aplicação > modules > packages > classes

-- Estrutura Sequencial --

*Expressões Aritméticas
Quando calculadas, o resultado é um valor númerico. 
Ex.: 4 + 5 = 9

*Operadores Aritméticos
Adição +
Subtração -
Multiplicação *
Divisão /
Resto da divisão ("mod") %

Precedência
1º: (o que está em parenteses), *, / e %
2º: + e -

*Variáveis e tipos básicos
Os dados que um software em execução deve lidar são armazenados em variáveis, que são armazenadas na memória RAM

*Declaração de variáveis
Sintaxe: <tipo> <nome> = <valor inicial>;
int idade = 25; (valor inteiro)
double altura = 1.68; (valor com ponto flutuante)
char genero = 'F'; (caracter unicode)
Uma variável possui nome, tipo, valor e endereço

*Tipos primitivos em Java
Numérico inteiro: byte (8bits - até 127), short (16bits - > 32k), int (32bits - a > 2 bilhoes), long (64bits - > 9 quintilhões), 
Numérico com ponto flutuante: float (32bits), double (64bits), 
Um caractere Unicode: char (16 bits), 
Valor verdade: booblean (1 bit)
* bit = 2 valores possíveis - 0 ou 1 => 8 bits = 2^8 = 256 possibilidades
String: cadeia de caracteres (palavras ou textos)

Nome de variáveis
- Deve começar com letra ou _
- Não pode ter espaço em branco
- Não usar acentos ou til
- Sugestão: use o padrão "camel case"
Exemplo:
int _5minutos;
int salarios;
int salarioDoFuncionario;

*Operações básicas de programação
Entrada de dados: usuário, através de um dispositivo de entrada como teclado, insere dados dentro do programa dentro de variáveis (ou leitura de dados);
Processamento de dados: realização de cálculos através da atribuição;
Saída de dados: o programa informa (ou escreve) dados para o usuário através de dispositivos de saída, como o monitor

*Processamento de Dados
Feito pelo comando de atribuição
<variável> = <expressão>;

A expressão é calculada e o resultado armazenado na variável

Exemplo:

int x, y;

x = 5;
y = 2 * x;

System.out.println(x); => 5
System.out.println(y); => 10.0

Casting
Conversão explícita (forçada) de valores

Exemplo:

int a, b;
double resultado;

a = 5;
b = 2;

(sem casting)
resultado = a / b; => 2.0
- entende-se que a divisão é entre 2 números inteiros, então o resultado será "arredondado", removendo valores decimais

(com casting)
resultado = (double) a / b; => 2.5

Exemplo:

double a;
int b;

a = 5.0;

(sem casting)
b = a; => nessa linha já apresenta erro
System.out.println(b); => Incompatible types: possible lossy conversion from double to int 

(com casting)
b = (int) a;
System.out.println(b); => 5


*Entrada de dados em Java
Para entrada de dados local, vamos criar um objeto do tipo "Scanner" da seguinte forma:

1º - importar
import java.util.Scanner;

2º - iniciar com:
Scanner sc = new Scanner(System.in);

3º - incluir variável onde a entrada será armazenada
String x;
x = sc.next(); => após essa linha, deverá ser digitado no console

4º - finalizar com:
sc.close();

Exemplo:

import java.util.Scanner;

public class Main{
	public static void main(String[] args){

	Scanner sc = new Scanner(System.in);
	
	String x;
	x = sc.next();
	*no console, digitar: "Olá"

	System.out.println(x); => Olá
	
	}
}

Para tipos 'String', utilizar 'next();'
Para tipos 'int' , utilizar 'nextInt();'
Para tipos 'double' ou 'float', utilizar 'nextDouble();'
Para tipos 'char', utilizar 'next().charAt(0);' O '0' é a posição do caracter que será armazenado
Para ler 'String' até a quebra de linha, ou seja, uma frase inteira com espaços até o enter, utilizar 'nextLine();'

*Funções matemáticas

A = Math.sqrt(x);
- Variavel A recebe a raiz quadrada de X

A = Math.pow(x, y);
- Variável A recebe o resultado de X elevado a Y

A = Math.abs(x);
- Variável A recebe o valor absoluto de X

*Expressões comparativas
Expressões onde dois itens são comparados e o resultado é um valor verdade, ou seja, verdadeiro ou falso
Usado em C, C++, Java e C#

Operadores:
> maior
< menor
>= maior ou igual
<= menor ou igual
== igual
!= diferente

Exemplo:

x = 5;

x > 0 (V)
x == 3 (F)
10 <= 30 (V)
x != 2 (V)

*Expressões lógicas
Usado em C, C++, Java e C#

Operadores:
&& E - todas as condições devem ser verdadeiras
|| OU - pelo menos uma condição deve ser verdadeira
! Não - inverte a condição

Exemplo &&:

x = 5;

x <= 20 && x == 10 (F)

x > 0 && x != 3 (V)

x <= 20 && x == 10 && x != 3 (F)


Exemplo ||:

x == 10 || x <= 20 (V)

x > 0 || x != 3 (V)

X <= 0 || X != 3 || x != 5 (V)


Exemplo !:

x = 5;

!(x == 10) (V)

!(x >= 2) (F)

!(x <= 20 && x == 10) (V)


-- Estrutura condicional --

É uma estrutura de controle que permite definir que um certo bloco de comandos somente será executado dependendo de uma condição - if-else pode ser encadeado se necessário

if(<condição 1>){
	<comando 1>
	<comando 2>
}else{
	if(<condição 2>){
		<comando 3>
		<comando 4>
	}else{
		<comando 5>
		<comando 6>
	}

}


*Operadores de atribuição cumulativa

a = a + b; => a += b;
a = a - b; => a -= b;
a = a * b; => a *= b;
a = a / b; => a /= b;
a = a % b; => a %= b; 

*Sintaxe opcional - switch-case
Quando se tem várias opções de fluxo a serem tratadas com base no valor de uma variável, ao invés de várias estruturas if-else encadeadas, alguns preferem utilizar a estrutura switch-case.

	int x = sc.nextInt();
	String dia;
		
	switch (x){
		case 1:
			dia = "Domingo";
			break;
		case 2:
			dia = "Segunda-Feira";
			break;
		case 3:
			dia = "Terca-Feira";
			break;
		case 4:
			dia = "Quarta-Feira";
			break;
		case 5:
			dia = "Quinta-Feira";
			break;
		case 6:
			dia = "Sexta-Feira";
			break;
		case 7:
			dia = "Sabado";
			break;
		default:
			dia = "valor invalido";
			break;
	}
		
		
	System.out.println("Dia da semana: " + dia);


*Expressão condicional ternária

Estrutura opcional ao if-else quando se desejar decidir um valor com base em uma condição

Sintaxe:
(condição) ? valor_se_verdadeiro: valor_se_falso

Exemplos:
(2 > 4) ? 50 : 80 => 80
(10 != 3) ? "Maria" : "João" => "Maria"

ANTES
double preco = 34.5;
double desconto;
if (preco < 20.0){
	desconto = preco * 0.1;
}
else{
	desconto = preco * 0.05;
}
DEPOIS
double preco = 34.5;
double desconto = (preco < 20.0) ? preco * 0.1 : preco * 0.05;

*Escopo e inicialização

- Escopo de uma variável: é a região do programa onde a variável é válida, ou seja, onde ela pode ser referenciada
- Uma variável não pode ser usada se não for iniciada

Exemplo:

double price;
System.out.println(price); 
=> apresentaria erro pois a variavel x não foi iniciada, ou seja, não recebeu valor inicial


double price = 400.00;
if(price < 200.00){
	double discount = price * 0.1;
}
System.out.println(discount); 
=> apresentaria ERRO pois a variavel discount foi declarada e iniciada apenas dentro da estrutura condicional 'if', estando fora do escopo do método 'main' 
Qualquer estrutura condicional tem seu próprio escopo, e as variaveis declaradas dentro delas só existirão enquanto essa estrutura está sendo executada

-- Estruturas Repetitivas--

*Estrutura repetitiva 'enquanto' (while)

É uma estrutura de controle que repete um bloco de comandos enquanto uma condição for verdadeira. Quando usar: quando não sabe previamente a quantidade de repetições que será realizadas. Enquanto a condição for atendida, a estrutura continuará sendo executada. Assim que a condição não for mais satisfeita, o programa encerra a execução.

Sintaxe:

while (condicao) {
	comando 1
	comando 2
}

Exemplo:

int x = sc.nextInt();
while (x != 0){
	x = sc.nextInt();
}

*Estrutura repetitiva 'para' (for)

É uma estrutura de controle que repete um bloco de comandos para um certo intervalo de valores. Quando usar: quando se sabe previamente a quantidade de repetições, ou o intervalo de valores.

Sintaxe:

for( Ínicio ; Condição ; Incremento ){
	comando 1
	comando 2
}

Ínicio - executa somente a primeira vez
Condição - se verdadeiro, executa e volta; se falso, encerra
Incremento - executa toda vez depois de voltar

Exemplos:

int N = sc.nextInt();

int soma = 0;
for(int i = 0; i < N; i++){
	int x = sc.nextInt();
	soma = soma + x;
}

Exemplo contagem progressiva:
for(int i = 0; i < 5; i++){
	System.out.println("Valor de i: " + i); 
}

Exemplo contagem regressiva:
for(int i = 4; i >= 0; i--){
	System.out.println("Valor de i: " + i); 
}

*Estrutura repetitiva 'faça-enquanto' (do-while)

Menos utilizada, mas em alguns casos se encaixa melhor ao problema. O bloco de comandos executa pelo menos uma vez, pois a condição é verificada no final.

Sintaxe:

do{
	comando 1
	comando 2
} while ( condicao );

Primeiro é executao o bloco de comandos, então depois a condição é verificada e enquanto for verdadeira, o bloco continuará a ser executado. Caso contrario, encerra o processo.


-- Outros tópicos básicos Java --

*Restrições e convenções para nomes

- não pode começar com digito - apenas letra ou _
- não usar acento ou til
- não pode ter espaço
- camelCase - pacotes, atributos, métodos, variáveis e parametros
- PascalCase - apenas classes

*Operadores bitwise
Realizam operações lógicas bit a bit em valores; NÃO CONFUDIR com operadores de lógica (&&, ||, !)

& - operação "E" bit a bit => só será verdadeiro (1) se todos forem verdadeiro
| - operação "OU" bit a bit => só será falso (0) se todos forem falso
^ - operação "OU-exclusivo" bit a bit => será falso (0) se todos forem falso ou todos forem verdadeiro, e será verdadeiro (1) se pelo menos um for verdadeiro 


Sabemos que cada número inteiro tem uma representação binária internamente no computador. Pra saber, pode ser utilizada a calculadora de programador no computador, que mostrará o equivalente de um inteiro como hexadecimal, octadecimal e binário. 

Exemplo:

*os números acima serão comparados bit a bit, ou seja, em sua forma binária, comparando o primeiro com o primeiro, o segundo com o segundo, etc. Nesse caso, o resultado também será binário onde o 0 representará falso e o 1 verdadeiro.

int n1 = 89; => bin 0101 1001
int n2 = 60; => bin 0011 1100

System.out.println(n1 & n2); => 24 => bin 0001 1000 
System.out.println(n1 | n2); => 125 => bin 0111 1101 
System.out.println(n1 ^ n2); => 101 => bin 0110 0101 

Esse tipo de operação se aplica em programação de baixo nível como um microcontrolador, programação de interface com rede, arduino, etc.
Exemplo de verificação bit de um endereço de rede, onde queremos verificar se o 6° bit é 0 ou 1 (lembrando que conta-se da direita para esquerda) -> aplica-se uma máscara, que é um número onde 6° bit é 1 e o restante 0, resultando no decimal 32

(89) 0101 1001
(32) 0010 0000

&: 0000 0000 (0)

(113) 0111 0001
(32) 0010 0000

&: 0010 0000 (32) <

*Funções interessantes para strings

- Formatar: toLowerCase() - torna minuscula, toUpperCase() - torna maiuscula, trim() - reomve espaços
- Recortar: substring(inicio), substring(inicio, fim) - recorta string informando inicio ou inicio e fim
- Substituir: Replace(char, char), Replace(string, string) - substitui caracteres ou substrings em uma string
- Buscar: IndexOf, LastIndexOf - buscar posição de alguma parte da string
- Split("") - recortar string como base no separador informado


String original = "abcde FGHIJ ABC abc DEFG    ";
		
String s01 = original.toLowerCase(); 
String s02 = original.toUpperCase(); 
String s03 = original.trim(); 
String s04 = original.substring(2); //será criada uma nova string utilizando o conteúdo a partir do caractere na posição informada, 2 
String s05 = original.substring(2, 9); //será criada uma nova string utilizando o conteúdo a partir do caractere na primeira posição informada, 2, ATÉ a segunda posição informada, 9
String s06 = original.replace('a', 'x'); //o primeiro caractere informado, 'a', todos os 'a's minúsculos, serão trocados pelo segundo caractere informado, 'x'
String s07 = original.replace("abc", "xy");
int i = original.indexOf("bc"); //recupera a posição a primeira ocorrencia do parametro, 1, em relação ao que foi informado, "bc"
int j = original.lastIndexOf("bc");//recupera a posição da última ocorrencia do parametro, 17, em relação ao que foi informado, "bc"

String s = "potato apple lemon";
		
String[] vect = s.split(" ");
		
System.out.println(vect[0]); //potato
System.out.println(vect[1]); //apple
System.out.println(vect[2]); //lemon

*Funções (Sintaxe)
Representam um processamento que possui um significado 
- Math.sqrt(double)
- System.out.println(string)

- Principais Vantagens: modularização, delegação e reaproveitamento
- Dados de entrada e saída
	- Funções podem receber dados de entrada (parâmetros ou argumentos)
	- Funções podem ou não retornar uma saída
- Em orientação a objetos, funções em classes recebem o nome de "métodos"

-- Introdução à Programação Orientada a Objetos --

*Resolvendo um problema sem orientação a objetos

/*
* Fazer um programa para ler as medidas dos lados de dois triângulos X e Y
* (suponha medidas válidas). Em seguida, mostrar o valor das áreas dos dois
* triângulos e dizer qual dos dois triângulos possui a maior área. A fórmula
* para calcular a área de um triângulo a partir das medidas de seus lados a, b
* e c é a seguinte (fórmula de Heron): area = raiz quadrada de
* p(p-a)(p-b)(p-c), onde p=(a+b+c)/2
*/
		
double xA, xB, xC, yA, yB, yC;
		
System.out.println("Digite as medidas do triângulo X:");
xA = sc.nextDouble();
xB = sc.nextDouble();
xC = sc.nextDouble();
		
System.out.println("Digite as medidas do triângulo Y:");
yA = sc.nextDouble();
yB = sc.nextDouble();
yC = sc.nextDouble();
		
double p = (xA + xB + xC) / 2.0;
double areaX = Math.sqrt(p * (p - xA) * (p - xB) * (p - xC));
		
p = (yA + yB + yC) / 2.0;
double areaY = Math.sqrt(p * (p - yA) * (p - yB) * (p - yC));
		
System.out.printf("Área do triângulo X: %.4f%n", areaX);
		
System.out.printf("Área do triângulo Y: %.4f%n", areaY);
		
if(areaX > areaY) {
	System.out.println("Maior área: X");
}else {
	System.out.println("Maior área: Y");
}

*Criando uma classe com 3 atributos para representar melhor o triângulo

Triângulo é uma entidade com 3 atributos: a, b e c.
Estamos usando 3 varáveis distintas para representar cada triângulo:
	double xA, xB, xC, yA, yB, yC;
Para melhorar isso, vamos usar uma classe para representar um triângulo.

- Classe: É um tipo estruturado que pode conter (membros):
	- Atributos (dados/campos)
	- Métodos (funções/operações)

A classe também pode prover muitos outros recursos, tais como:
	- Construtores
	- Sobrecarga
	- Encapsulamento
	- Herança
	- Polimorfismo

Exemplos:
	- Entidades: Produto, Cliente, Triangulo
	- Serviços: ProdutoService, ClienteService, EmailService, StorageService
	- Controladores: ProdutoController, ClienteController
	- Utilitários: Calculadora, Compactador

Portanto, criaremos uma classe pública chamada 'Triangle' em um package chamado 'entities' que conterá 3 atributos também públicos de tipo double

	package entities;
	public class Triangle{
		public double a;
		public double b;
		public double c;
	}

Então poderemos instanciar a classe para criar os objetos de x e y:

	Triangle x, y;
	x = new Triangle();
	y = new Triangle();

X e Y então poderão conter os 3 atributos correspondentes as 3 medidas

Para acessar e armazenar os valores nos atributos do objeto x:
	System.out.println("Digite as medidas do triângulo X:");
	x.a = sc.nextDouble();
	x.b = sc.nextDouble();
	x.c = sc.nextDouble();

Para acessar e armazenar os valores nos atributos do objeto y:
	System.out.println("Digite as medidas do triângulo Y:");
	y.a = sc.nextDouble();
	y.b = sc.nextDouble();
	y.c = sc.nextDouble();

	double p = (x.a + x.b + x.c) / 2.0;
	double areaX = Math.sqrt(p * (p - x.a) * (p - x.b) * (p - x.c));
		
	p = (y.a + y.b + y.c) / 2.0;
	double areaY = Math.sqrt(p * (p - y.a) * (p - y.b) * (p - y.c));
		
	System.out.printf("Área do triângulo X: %.4f%n", areaX);
		
	System.out.printf("Área do triângulo Y: %.4f%n", areaY);
		
	if(areaX > areaY) {
		System.out.println("Maior área: X");
	}else {
		System.out.println("Maior área: Y");
	}

*classe é a definição do tipo e objeto é a instanciação da classe

- Instanciação 

Exemplo:
double areaX, areaY, p;
Triangle x, y;

	-> Memória
		-> Stack - onde as variáveis estáticas como areaX, areaY e p são criadas.
		*Durante a exectação do programa, podemos fazer uma alocação dinâmica de memória através do 'new' utilizado para instanciar um objeto, que será armazenado no Heap		
		-> Heap - aqui são criados objetos dinâmicos através da alocação dinâmica de memória feita através do 'new'
		*as variáveis x e y, mesmo que objetos no heap, também estarão no Stack, mas armazenando um endereço de memória do objeto criado no Heap