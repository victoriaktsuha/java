[NOTAS] Java COMPLETO Programação Orientada a Objetos + Projetos

Entendendo versões Java

SE (Standard Edition) - versão padrão
LTS (Long Term Support) - versão mais utilizada por empresas por ter suporte por muitos anos

versões LTS
8  - Mar 2014 ~ Dec 2030 *
11 - Sep 2018 ~ Not Available
17 - Sep 2021 ~ Sep 2029
21 - Sep 2023 ~ Sep 2031
25 - Sep 2025 ~ Sep 2033

Java
- é uma linguagem de programação
- plataforma de desenvolvimento e execução
	- bibliotecas API
	- ambientes de execução

Problemas resolvidos e motivo de seu sucesso:
- Ponteiros / gerenciamento  de memória - utilizava a linguagem C/C++ onde definia-se manualmente quais variáveis eram ponteiro e quais eram valor, fazendo com que essas linguagens fossem de baixo nível, gerando dificuldade ao programador e softwares mais sucetiveis a erros
- Portabilidade falha: reescrever parte do código ao mudar de SO; Embora existe padrão e compiladores para várias plataformas, o dev tinha que reescrever parte do código para as diversas plataformas/SO
- Utilização em dispositivos diversos
- Custo

Criada pela Sun Microsystems no meio da década de 1990

Adquirida pela Oracle Corporation em 2010

Aspectos notáveis
- Código compilado para bytecode e executado em máquina virtual (JVM)
- Portável, segura, robusta
- Roda em vários tipos de dispositivos
- Domina o mercado corporativo desde o fim do século 20
- Padrão Android por muitos anos (recentemente também utiliza-se Kotlin)

Edições
- Java ME - Java Micro Edition - dispositivos embarcados e móveis - IoT
- Java SE - Java Standard Edition - core - desktop e servidores
- Java EE - Java Enterprise Edition - aplicações corporativas

Plataforma Java SE
- JVM - Java Virtual Machine - necessário para executar sistemas Java

Compilação e interpretação
- Linguagens compiladas: C, C++ 
(rápidas e menos sucetivel a bugs por serem compiladas antes mas de difícil portabilidade)
- Linguagens interpretadas: PHP, JavaScript 
(tem um interpretador para cada sistema, são mais lentas pois a interpretação é feita JIT (just in time), ou seja, no momento que está sendo executado, mais sucetivel a bugs pois a tipagem é mais fraca e não há um compilador que garanta um código assertivo, mas tem boa portabilidade e manutenção)
- Linguagens pré-compiladas + VM: Java, C#
(une o melhor das duas modalidades anteriores: o código será pré-compilado garantindo a sintaxe correta e resultando no bytecode, compilado JIT e rodando em uma VM para o sistema operacional específico)

Estrutura de um aplicação Java
Java é uma linguagem orientada a objetos e a unidade lógica básica de um programa orientado a objetos é a classe. Todo código Java tem que estar dentro de classes. Após a classe, existe o contexto de package, sendo um agrupamento lógico de classes relacionadas. Exemplo de packages são entities (produto, cliente, pedido), services (email, pedido, log) e repositories(banco de dados)). Após o package, existe o conceito de módulo, introduzido a partir do Java 9, sendo um agrupamento lógico de pacotes relacionados. Exemplo de módulo seria um 'financeiro' contendo entidades, serviços e repositórios relacionados a pagamentos, contabilidade, etc. O 'runtime' ou 'build' representa um agrupamento físico de arquivos, sendo uma unidade que pode ser instalado para rodar em demais dispositivos. Após o modulo, tem a aplicação, sendo um agrupamento de módulos relacionados. Um exemplo seria um sistema de comercio eletronico, composto por vários módulos, que por sua vez, é composto por packages, que é composto por classes.
Aplicação > modules > packages > classes


----------------------------------------------
-- Estrutura Sequencial --

*Expressões Aritméticas
Quando calculadas, o resultado é um valor númerico. 
Ex.: 4 + 5 = 9

*Operadores Aritméticos
Adição +
Subtração -
Multiplicação *
Divisão /
Resto da divisão ("mod") %

Precedência
1º: (o que está em parenteses), *, / e %
2º: + e -

*Variáveis e tipos básicos
Os dados que um software em execução deve lidar são armazenados em variáveis, que são armazenadas na memória RAM

*Declaração de variáveis
Sintaxe: <tipo> <nome> = <valor inicial>;
int idade = 25; (valor inteiro)
double altura = 1.68; (valor com ponto flutuante)
char genero = 'F'; (caracter unicode)
Uma variável possui nome, tipo, valor e endereço

*Tipos primitivos em Java
Numérico inteiro: byte (8bits - até 127), short (16bits - > 32k), int (32bits - a > 2 bilhoes), long (64bits - > 9 quintilhões), 
Numérico com ponto flutuante: float (32bits), double (64bits), 
Um caractere Unicode: char (16 bits), 
Valor verdade: booblean (1 bit)
* bit = 2 valores possíveis - 0 ou 1 => 8 bits = 2^8 = 256 possibilidades
String: cadeia de caracteres (palavras ou textos)

Nome de variáveis
- Deve começar com letra ou _
- Não pode ter espaço em branco
- Não usar acentos ou til
- Sugestão: use o padrão "camel case"
Exemplo:
int _5minutos;
int salarios;
int salarioDoFuncionario;

*Operações básicas de programação
Entrada de dados: usuário, através de um dispositivo de entrada como teclado, insere dados dentro do programa dentro de variáveis (ou leitura de dados);
Processamento de dados: realização de cálculos através da atribuição;
Saída de dados: o programa informa (ou escreve) dados para o usuário através de dispositivos de saída, como o monitor

*Processamento de Dados
Feito pelo comando de atribuição
<variável> = <expressão>;

A expressão é calculada e o resultado armazenado na variável

Exemplo:

int x, y;

x = 5;
y = 2 * x;

System.out.println(x); => 5
System.out.println(y); => 10.0

Casting
Conversão explícita (forçada) de valores

Exemplo:

int a, b;
double resultado;

a = 5;
b = 2;

(sem casting)
resultado = a / b; => 2.0
- entende-se que a divisão é entre 2 números inteiros, então o resultado será "arredondado", removendo valores decimais

(com casting)
resultado = (double) a / b; => 2.5

Exemplo:

double a;
int b;

a = 5.0;

(sem casting)
b = a; => nessa linha já apresenta erro
System.out.println(b); => Incompatible types: possible lossy conversion from double to int 

(com casting)
b = (int) a;
System.out.println(b); => 5


*Entrada de dados em Java
Para entrada de dados local, vamos criar um objeto do tipo "Scanner" da seguinte forma:

1º - importar
import java.util.Scanner;

2º - iniciar com:
Scanner sc = new Scanner(System.in);

3º - incluir variável onde a entrada será armazenada
String x;
x = sc.next(); => após essa linha, deverá ser digitado no console

4º - finalizar com:
sc.close();

Exemplo:

import java.util.Scanner;

public class Main{
	public static void main(String[] args){

	Scanner sc = new Scanner(System.in);
	
	String x;
	x = sc.next();
	*no console, digitar: "Olá"

	System.out.println(x); => Olá
	
	}
}

Para tipos 'String', utilizar 'next();'
Para tipos 'int' , utilizar 'nextInt();'
Para tipos 'double' ou 'float', utilizar 'nextDouble();'
Para tipos 'char', utilizar 'next().charAt(0);' O '0' é a posição do caracter que será armazenado
Para ler 'String' até a quebra de linha, ou seja, uma frase inteira com espaços até o enter, utilizar 'nextLine();'

*Funções matemáticas

A = Math.sqrt(x);
- Variavel A recebe a raiz quadrada de X

A = Math.pow(x, y);
- Variável A recebe o resultado de X elevado a Y

A = Math.abs(x);
- Variável A recebe o valor absoluto de X

*Expressões comparativas
Expressões onde dois itens são comparados e o resultado é um valor verdade, ou seja, verdadeiro ou falso
Usado em C, C++, Java e C#

Operadores:
> maior
< menor
>= maior ou igual
<= menor ou igual
== igual
!= diferente

Exemplo:

x = 5;

x > 0 (V)
x == 3 (F)
10 <= 30 (V)
x != 2 (V)

*Expressões lógicas
Usado em C, C++, Java e C#

Operadores:
&& E - todas as condições devem ser verdadeiras
|| OU - pelo menos uma condição deve ser verdadeira
! Não - inverte a condição

Exemplo &&:

x = 5;

x <= 20 && x == 10 (F)

x > 0 && x != 3 (V)

x <= 20 && x == 10 && x != 3 (F)


Exemplo ||:

x == 10 || x <= 20 (V)

x > 0 || x != 3 (V)

X <= 0 || X != 3 || x != 5 (V)


Exemplo !:

x = 5;

!(x == 10) (V)

!(x >= 2) (F)

!(x <= 20 && x == 10) (V)

-----------------------------------------
-- Estrutura condicional --

É uma estrutura de controle que permite definir que um certo bloco de comandos somente será executado dependendo de uma condição - if-else pode ser encadeado se necessário

if(<condição 1>){
	<comando 1>
	<comando 2>
}else{
	if(<condição 2>){
		<comando 3>
		<comando 4>
	}else{
		<comando 5>
		<comando 6>
	}

}


*Operadores de atribuição cumulativa

a = a + b; => a += b;
a = a - b; => a -= b;
a = a * b; => a *= b;
a = a / b; => a /= b;
a = a % b; => a %= b; 

*Sintaxe opcional - switch-case
Quando se tem várias opções de fluxo a serem tratadas com base no valor de uma variável, ao invés de várias estruturas if-else encadeadas, alguns preferem utilizar a estrutura switch-case.

	int x = sc.nextInt();
	String dia;
		
	switch (x){
		case 1:
			dia = "Domingo";
			break;
		case 2:
			dia = "Segunda-Feira";
			break;
		case 3:
			dia = "Terca-Feira";
			break;
		case 4:
			dia = "Quarta-Feira";
			break;
		case 5:
			dia = "Quinta-Feira";
			break;
		case 6:
			dia = "Sexta-Feira";
			break;
		case 7:
			dia = "Sabado";
			break;
		default:
			dia = "valor invalido";
			break;
	}
		
		
	System.out.println("Dia da semana: " + dia);


*Expressão condicional ternária

Estrutura opcional ao if-else quando se desejar decidir um valor com base em uma condição

Sintaxe:
(condição) ? valor_se_verdadeiro: valor_se_falso

Exemplos:
(2 > 4) ? 50 : 80 => 80
(10 != 3) ? "Maria" : "João" => "Maria"

ANTES
double preco = 34.5;
double desconto;
if (preco < 20.0){
	desconto = preco * 0.1;
}
else{
	desconto = preco * 0.05;
}
DEPOIS
double preco = 34.5;
double desconto = (preco < 20.0) ? preco * 0.1 : preco * 0.05;

*Escopo e inicialização

- Escopo de uma variável: é a região do programa onde a variável é válida, ou seja, onde ela pode ser referenciada
- Uma variável não pode ser usada se não for iniciada

Exemplo:

double price;
System.out.println(price); 
=> apresentaria erro pois a variavel x não foi iniciada, ou seja, não recebeu valor inicial


double price = 400.00;
if(price < 200.00){
	double discount = price * 0.1;
}
System.out.println(discount); 
=> apresentaria ERRO pois a variavel discount foi declarada e iniciada apenas dentro da estrutura condicional 'if', estando fora do escopo do método 'main' 
Qualquer estrutura condicional tem seu próprio escopo, e as variaveis declaradas dentro delas só existirão enquanto essa estrutura está sendo executada

---------------------------------------------
-- Estruturas Repetitivas--

*Estrutura repetitiva 'enquanto' (while)

É uma estrutura de controle que repete um bloco de comandos enquanto uma condição for verdadeira. Quando usar: quando não sabe previamente a quantidade de repetições que será realizadas. Enquanto a condição for atendida, a estrutura continuará sendo executada. Assim que a condição não for mais satisfeita, o programa encerra a execução.

Sintaxe:

while (condicao) {
	comando 1
	comando 2
}

Exemplo:

int x = sc.nextInt();
while (x != 0){
	x = sc.nextInt();
}

*Estrutura repetitiva 'para' (for)

É uma estrutura de controle que repete um bloco de comandos para um certo intervalo de valores. Quando usar: quando se sabe previamente a quantidade de repetições, ou o intervalo de valores.

Sintaxe:

for( Ínicio ; Condição ; Incremento ){
	comando 1
	comando 2
}

Ínicio - executa somente a primeira vez
Condição - se verdadeiro, executa e volta; se falso, encerra
Incremento - executa toda vez depois de voltar

Exemplos:

int N = sc.nextInt();

int soma = 0;
for(int i = 0; i < N; i++){
	int x = sc.nextInt();
	soma = soma + x;
}

Exemplo contagem progressiva:
for(int i = 0; i < 5; i++){
	System.out.println("Valor de i: " + i); 
}

Exemplo contagem regressiva:
for(int i = 4; i >= 0; i--){
	System.out.println("Valor de i: " + i); 
}

*Estrutura repetitiva 'faça-enquanto' (do-while)

Menos utilizada, mas em alguns casos se encaixa melhor ao problema. O bloco de comandos executa pelo menos uma vez, pois a condição é verificada no final.

Sintaxe:

do{
	comando 1
	comando 2
} while ( condicao );

Primeiro é executao o bloco de comandos, então depois a condição é verificada e enquanto for verdadeira, o bloco continuará a ser executado. Caso contrario, encerra o processo.

----------------------------------------------
-- Outros tópicos básicos Java --

*Restrições e convenções para nomes

- não pode começar com digito - apenas letra ou _
- não usar acento ou til
- não pode ter espaço
- camelCase - pacotes, atributos, métodos, variáveis e parametros
- PascalCase - apenas classes

*Operadores bitwise
Realizam operações lógicas bit a bit em valores; NÃO CONFUDIR com operadores de lógica (&&, ||, !)

& - operação "E" bit a bit => só será verdadeiro (1) se todos forem verdadeiro
| - operação "OU" bit a bit => só será falso (0) se todos forem falso
^ - operação "OU-exclusivo" bit a bit => será falso (0) se todos forem falso ou todos forem verdadeiro, e será verdadeiro (1) se pelo menos um for verdadeiro 


Sabemos que cada número inteiro tem uma representação binária internamente no computador. Pra saber, pode ser utilizada a calculadora de programador no computador, que mostrará o equivalente de um inteiro como hexadecimal, octadecimal e binário. 

Exemplo:

*os números acima serão comparados bit a bit, ou seja, em sua forma binária, comparando o primeiro com o primeiro, o segundo com o segundo, etc. Nesse caso, o resultado também será binário onde o 0 representará falso e o 1 verdadeiro.

int n1 = 89; => bin 0101 1001
int n2 = 60; => bin 0011 1100

System.out.println(n1 & n2); => 24 => bin 0001 1000 
System.out.println(n1 | n2); => 125 => bin 0111 1101 
System.out.println(n1 ^ n2); => 101 => bin 0110 0101 

Esse tipo de operação se aplica em programação de baixo nível como um microcontrolador, programação de interface com rede, arduino, etc.
Exemplo de verificação bit de um endereço de rede, onde queremos verificar se o 6° bit é 0 ou 1 (lembrando que conta-se da direita para esquerda) -> aplica-se uma máscara, que é um número onde 6° bit é 1 e o restante 0, resultando no decimal 32

(89) 0101 1001
(32) 0010 0000

&: 0000 0000 (0)

(113) 0111 0001
(32) 0010 0000

&: 0010 0000 (32) <

*Funções interessantes para strings

- Formatar: toLowerCase() - torna minuscula, toUpperCase() - torna maiuscula, trim() - reomve espaços
- Recortar: substring(inicio), substring(inicio, fim) - recorta string informando inicio ou inicio e fim
- Substituir: Replace(char, char), Replace(string, string) - substitui caracteres ou substrings em uma string
- Buscar: IndexOf, LastIndexOf - buscar posição de alguma parte da string
- Split("") - recortar string como base no separador informado


String original = "abcde FGHIJ ABC abc DEFG    ";
		
String s01 = original.toLowerCase(); 
String s02 = original.toUpperCase(); 
String s03 = original.trim(); 
String s04 = original.substring(2); //será criada uma nova string utilizando o conteúdo a partir do caractere na posição informada, 2 
String s05 = original.substring(2, 9); //será criada uma nova string utilizando o conteúdo a partir do caractere na primeira posição informada, 2, ATÉ a segunda posição informada, 9
String s06 = original.replace('a', 'x'); //o primeiro caractere informado, 'a', todos os 'a's minúsculos, serão trocados pelo segundo caractere informado, 'x'
String s07 = original.replace("abc", "xy");
int i = original.indexOf("bc"); //recupera a posição a primeira ocorrencia do parametro, 1, em relação ao que foi informado, "bc"
int j = original.lastIndexOf("bc");//recupera a posição da última ocorrencia do parametro, 17, em relação ao que foi informado, "bc"

String s = "potato apple lemon";
		
String[] vect = s.split(" ");
		
System.out.println(vect[0]); //potato
System.out.println(vect[1]); //apple
System.out.println(vect[2]); //lemon

*Funções (Sintaxe)
Representam um processamento que possui um significado 
- Math.sqrt(double)
- System.out.println(string)

- Principais Vantagens: modularização, delegação e reaproveitamento
- Dados de entrada e saída
	- Funções podem receber dados de entrada (parâmetros ou argumentos)
	- Funções podem ou não retornar uma saída
- Em orientação a objetos, funções em classes recebem o nome de "métodos"

---------------------------------------------------
-- Introdução à Programação Orientada a Objetos --

*Resolvendo um problema sem orientação a objetos

/*
* Fazer um programa para ler as medidas dos lados de dois triângulos X e Y
* (suponha medidas válidas). Em seguida, mostrar o valor das áreas dos dois
* triângulos e dizer qual dos dois triângulos possui a maior área. A fórmula
* para calcular a área de um triângulo a partir das medidas de seus lados a, b
* e c é a seguinte (fórmula de Heron): area = raiz quadrada de
* p(p-a)(p-b)(p-c), onde p=(a+b+c)/2
*/
		
double xA, xB, xC, yA, yB, yC;
		
System.out.println("Digite as medidas do triângulo X:");
xA = sc.nextDouble();
xB = sc.nextDouble();
xC = sc.nextDouble();
		
System.out.println("Digite as medidas do triângulo Y:");
yA = sc.nextDouble();
yB = sc.nextDouble();
yC = sc.nextDouble();
		
double p = (xA + xB + xC) / 2.0;
double areaX = Math.sqrt(p * (p - xA) * (p - xB) * (p - xC));
		
p = (yA + yB + yC) / 2.0;
double areaY = Math.sqrt(p * (p - yA) * (p - yB) * (p - yC));
		
System.out.printf("Área do triângulo X: %.4f%n", areaX);
		
System.out.printf("Área do triângulo Y: %.4f%n", areaY);
		
if(areaX > areaY) {
	System.out.println("Maior área: X");
}else {
	System.out.println("Maior área: Y");
}

*Criando uma classe com 3 atributos para representar melhor o triângulo

Triângulo é uma entidade com 3 atributos: a, b e c.
Estamos usando 3 varáveis distintas para representar cada triângulo:
	double xA, xB, xC, yA, yB, yC;
Para melhorar isso, vamos usar uma classe para representar um triângulo.

- Classe: É um tipo estruturado que pode conter (membros):
	- Atributos (dados/campos)
	- Métodos (funções/operações)

A classe também pode prover muitos outros recursos, tais como:
	- Construtores
	- Sobrecarga
	- Encapsulamento
	- Herança
	- Polimorfismo

Exemplos:
	- Entidades: Produto, Cliente, Triangulo
	- Serviços: ProdutoService, ClienteService, EmailService, StorageService
	- Controladores: ProdutoController, ClienteController
	- Utilitários: Calculadora, Compactador

Portanto, criaremos uma classe pública chamada 'Triangle' em um package chamado 'entities' que conterá 3 atributos também públicos de tipo double

	package entities;
	public class Triangle{
		public double a;
		public double b;
		public double c;
	}

Então poderemos instanciar a classe para criar os objetos de x e y:

	Triangle x, y;
	x = new Triangle();
	y = new Triangle();

X e Y então poderão conter os 3 atributos correspondentes as 3 medidas

Para acessar e armazenar os valores nos atributos do objeto x:
	System.out.println("Digite as medidas do triângulo X:");
	x.a = sc.nextDouble();
	x.b = sc.nextDouble();
	x.c = sc.nextDouble();

Para acessar e armazenar os valores nos atributos do objeto y:
	System.out.println("Digite as medidas do triângulo Y:");
	y.a = sc.nextDouble();
	y.b = sc.nextDouble();
	y.c = sc.nextDouble();

	double p = (x.a + x.b + x.c) / 2.0;
	double areaX = Math.sqrt(p * (p - x.a) * (p - x.b) * (p - x.c));
		
	p = (y.a + y.b + y.c) / 2.0;
	double areaY = Math.sqrt(p * (p - y.a) * (p - y.b) * (p - y.c));
		
	System.out.printf("Área do triângulo X: %.4f%n", areaX);
		
	System.out.printf("Área do triângulo Y: %.4f%n", areaY);
		
	if(areaX > areaY) {
		System.out.println("Maior área: X");
	}else {
		System.out.println("Maior área: Y");
	}

*classe é a definição do tipo e objeto é a instanciação da classe

- Instanciação 

Exemplo:
double areaX, areaY, p;
Triangle x, y;

	-> Memória
		-> Stack - onde as variáveis estáticas como areaX, areaY e p são criadas.
		*Durante a exectação do programa, podemos fazer uma alocação dinâmica de memória através do 'new' utilizado para instanciar um objeto, que será armazenado no Heap		
		-> Heap - aqui são criados objetos dinâmicos através da alocação dinâmica de memória feita através do 'new'
		*as variáveis x e y, mesmo que objetos no heap, também estarão no Stack, mas armazenando um endereço de memória do objeto criado no Heap

*Criando um método para obtermos os benefícios de reaproveitamento e delegação

Com o uso da Classe, agora nós temos uma variável composta do tipo "Triangle" para representar cada triângulo:

Triangle x, y;
x = new Triangle();
y = new Triangle();

Agora vamos melhorar nossa classe acrescentando nela um método para calcular a área.

Projeto da classe (UML)
- Diagrama de classes: 1º nome da classe, 2º atributos da classe e 3º métodos da classe

Quais são os benefícios de se calcular a área de um triângulo por meio de um método dentro da classe Triangle ?
- Reaproveitamento de código: nós eliminamos o código repetido (cálculo das áreas dos triângulos x e y) no programa principal.
- Delegação das responsabilidades: quem deve ser responsável por saber como calcular a área de um triângulo é o próprio triângulo. A lógica do cálculo da área não deve estar em outro lugar.

*Começando a resolver um segundo problema exemplo

Fazer um programa para ler os dados de um produto em estoque (nome, preço e qauntidade no estoque.) Em seguida:
- Mostrar os dados do produto (nome, preço, quantidade no estoque, valor total no estoque)
- Realizar uma entrada no estoque e mostrar novamente os dados do produto
- Realizar uma saída no estoque e mostrar novamente os dados do produto

Para resolver este problema, você deve criar uma classe conforme projeto ao lado:

------------------------------------
Product
------------------------------------
- Name: string
- Price: double
- Quantity: int
------------------------------------
+ TotalValueInStock():double
+ AddProducts(quantity:int):void
+ RemoveProducts(quantity:int):void
------------------------------------

*Object e toString
- Toda classe java é uma subclasse da classe Object
	- Qualquer variável que você tiver no seu programa, ela vai ser um tipo - ex.: Triangle, Product - e cada um desses também é do tipo Object, e o tipo Object tem alguns métodos padrão.

- Object possui os seguintes métodos:
	- getClass - retorna o tipo do objeto
	- equals - compara se o objeto é igual ao outro
	- hashCode - retorna um código hash do objeto
	- toString - converte o objeto para string


Utilizando o exercicio anterior como exemplo, como a classe Product também é um Object, estamos sobrepondo a classe padrão toString. Então todos os retornos que estiverem aqui dentro, serão automaticamente impressos no console quando o objeto do tipo Product estiver em um contexto de System.out.print, podendo já ser formatado corretamente aqui para depois só ser 'chamado'.

public String toString() {
	return name
	+ ", $ "
	+ String.format("%.2f", price) //formatação para imprimir 2 casas decimais
	+ ", "
	+ quantity
	+ " units, Total: $ "
	+ String.format("%.2f",totalValueInStock());
}

*Exercícios

1) Fazer um programa para ler os valores da largura e altura de um retângulo. Em seguida, mostrar na tela o valor de sua área, perímetro e diagonal. User uma classe como mostardo no UML abaixo:

-----------------------
Rectangle
-----------------------
- Width: double
- Height: double
-----------------------
+ Area(): double
+ Perimeter(): double
+ Diagonal(): double
-----------------------

Exemplo:
Enter rectangle width and height:
3.00
4.00
AREA = 12.00
PERIMETER = 14.00
DIAGONAL = 5.00

2) Fazer um programa para ler os dados de um funcionário (nome, salário bruto e imposto). Em seguida, mostrar os dados do funcionário (nome e salário líquido). Em seguida, aumentar o salário do funcionário com base em uma porcentagem dada (somente o salário bruto é afetado pela porcentagem) e mostar novamente os dados do funcionário. Use a classe projetada abaixo:

-------------------------------------------
Employee
-------------------------------------------
- Name: String
- GrossSalary: souble
- Tax: double
-------------------------------------------
+ NetSalary(): double
+ IncreaseSalary(percentage: double): void
-------------------------------------------

Exemplo:
Name: Joao Silva
Gross Salary: 6000.00
Tax: 1000.00

Employee: Joao Silva, $ 5000.00

Which percentage to increase salary ? 10.0

Updated data: Joao Silva, $ 5600.00

3) Fazer um programa para ler o nome de um aluno e as três notas que ele obteve nos três trimestres do ano (primeiro trimestre vale 30 e o segundo e terceiro valem 35 cada). Ao final, mostrar qual a nota final do aluno no ano. Dizer também se o aluno está aprovado (PASS) ou não (FAILED) e, em caso negativo, quantos pontos faltam para o aluno obter o mínimo para ser aprovado (que é 60% da nota). Você deve criar uma classe Student para resolver este problema. *elaborar diagrama de classe

Exemplos:
-------------------
Entrada:
Alex Green
27.00
31.00
32.00

Saída:
FINAL GRADE = 90.00
PASS
--------------------
Entrada:
Alex Green
17.00
20.00
15.00

Saída:
FINAL GRADE = 52.00
FAILED
MISSING 8.00 POINTS
---------------------

*Membros Estáticos

Uma classe possui membros, que são os atributos e métodos.

Os membros estáticos, também chamados de membros de classe - em oposição a membros e instância.
São membros que fazem sentido independentemente de objetos. Não precisam de objetos para serem chamados. São chamados a partir do próprio nome da classe.
No exemplo dos triângulos, x é uma instância e y é outra instância e é possível 'chamar' os membros mesmo em instancias diferentes, ou seja, independente do objeto. 

Aplicações comuns:
- classes utilitárias (Math.sqrt())
- declaração de constantes

Uma classe que possui somente membros estáticos, pode ser uma classe estática também. Esta classe não poderá ser instanciada.

Problema exemplo
Fazer um programa para ler um valor numérico qualquer, e daí mostrar quanto seria o valor de um circunferência e do volume de uma esfera para um raio daquele valor. Informar também o valor de PI com duas casas decimais.

Exemplo:
Enter radius: 3.0
Circumference: 18.84
Volume: 113.04
PI value: 3.14

Resolução em 3 versões:
1: métodos na própria classe do programa - dentro de um método estático você não pode chamar membros de instância da mesma classe
2: classe Calculator com membros de instância - principio de delegação - precisa de um objeto (new) para utilizar o membros das classe
3: classe Calculator com método estático - referencia a classe direto (classe utilitária)

Não podemos chamar um método que não é estático dentro de outro que é estático. Como o método 'main' é sempre 'static', então os demais métodos e variáveis também devem ser.

Exemplo de método não-estático
No exercício dos triângulos, o método Area() não é estático pois cada triangulo possui a sua area, o resultado não poderia ser o mesmo.

Exemplo de método estático
Já no caso da calculadora, os valores dos cálculos não mudam para 'calculadoras' (objetos) diferentes, ou seja, são cálculos estáticos. O valor de PI também é estático. 

*Exercícios de fixação
Faça um programa para ler a cotação do dólar, e depois um valor em dólares a ser comprado por uma pessoa em reais. Informar quantos reais a pessoa vai pagar pelos dólares, considerando ainda que a pessoa terá que pagar 6% de IOF sobre o valor em dólar. Criar uma classe CurrencyConverter para ser responsável pelos cálculos.

Exemplo:
What is the dollar price ? 3.10
How many dollars will be bought ? 200.00
Amount to be paid in reais = 657.20 

?? Quando classes são consideradas utilitárias e quando são consideradas entidades ?
Classes são consideradas utilitárias quando seus membros são estáticos ?


-------------------------------------------------------------
--Construtores, palavra this, sobrecarga, encapsulamento --

*Construtores

- É uma operação especial da classe, que executa no momento da instanciação do objeto

- Usos comuns:
	- Iniciar valores dos atributos
	- Permitir ou obrigar que o objeto receba dados / dependências no momento de sua instanciação (injeção da dependência)

- Se um construtor customizado não for especificado, a classe disponibiliza o construtor padrão: Product p = new Product();

- É possível especificar mais de um construtor na mesma classe (sobrecarga)

public class Product {
	public String name;
	public double price;
	public int quantity;
	
	//construtor - executa no momento da instanciação do objeto
	public Product(String name, double price, int quantity) {
		//'this' para se referir ao atributo do objeto, não ao do parâmetro
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
}

*Palavra this

É uma referência para o próprio objeto

- Usos comuns:
	- Diferenciar atributos de variáveis locais
	- Passar o próprio objeto como argumento na chamada de um método ou construtor

Exemplo:
- Program (main)
Product product = new Product("TV", 1500.0, 0);
	- Os valores passados aos parametros ao instanciar a classe, estão atualmente no escopo do construtor, que está na memória do computador.

- Product (entity)
public class Product {
	public String name;
	public double price;
	public int quantity;
	
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
}
	- Os valores passados aos parametros do construtor anteriormente serão copiados para para os atributos do objeto, que está diretamente armazenada na memória.

*Sobrecarga

É um recurso que uma classe possui de oferecer mais de uma operação com o mesmo nome, porém com diferentes listas de parâmetros.

//1º construtor
public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}

//2º construtor opcional
public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}

Pode ser declarada uma versão padrão, sem parâmetros:
public Product() {}

*Encapsulamento
- É um princípio que consiste em esconder detalhes de implementação de uma classe, expondo apenas operações seguras e que mantenham os objetos em um estado consistente.
- Regra de ouro: o objeto deve sempre estar em um estado consistente, e a própria classe deve garantir isso.

Analogia:
Um aparelho eletrônico esconde todos os circuitos e componentes internos e vai disponibilizar ao usuário apenas operações/interações que não vão corromper a integridade do aparelho

Regra geral básica:
- Um objeto não deve expor nenhum atributo (modificador de acesso private)
- Os atributos devem ser acessados por meio de métodos get e set (padrão JavaBeans)

Padrão para implementação de getters e setters


private String name;
private double price;
(private indica que não deve ser acessado por outras classes - para acessar e alterar os atributos, utilizar os métodos abaixo)

public String getName(){
	return name;
}

public void setName(String name){
	this.name = name;
}

public double getPrice(){
	return price;
}

public void setPrice(double price){
	this.price = price;
}

*Gerando automaticamente construtores, getters e setters com Eclipse
- Botão direito > Source > Generate Constructor using Fields
- Botão direito > Source > Generate Getters and Setters

*Modificadores de acesso

- private: o membro só pode ser acessado na própria classe
- (nada): o membro só pode ser acessado nas classes do mesmo pacote
- protected: o membro só pode ser acessado no mesmo pacote, bem como em subclasses de pacotes diferentes
- public: o membro é acessado por todas as classes (ao menos que ele resida em um módulo diferente que não exporte o pacote onde ele está)
https://i.sstatic.net/SVk2a.png


------------------------------------------------
-- Comportamento de memória, arrays, listas --

*Tipos referência vs. tipos valor

- Classes são tipos referência
Variáveis cujo tipo são classes não devem ser entendidas como caixas, mas sim como "tentáculos" (ponteiros) para caixas, pois a classe/variável (memoria > stack) irá armazenar o endereço/referência onde está o objeto (memoria > heap)

Exemplo:

Product p1, p2; (p1 e p2 são criados em memoria > stack)

p1 = new Product("TV", 900.00, 0); (p1 ainda em stack passa a apontar para o objeto "new Product("TV", 900.00, 0)" em memoria > heap)
p2 = p1; => p2 passa a apontar para onde p1 aponta

- Valor "null"

Tipos referência aceitam o valor "null", que indica que a variável aponta para nada.

Product p1, p2; (p1 e p2 são criados em memoria > stack)

p1 = new Product("TV", 900.00, 0); =>p1 ainda em stack passa a apontar para o objeto "new Product("TV", 900.00, 0)" em memoria > heap
p2 = null; => p2 não recebe nenhum armazena nenhum endereço/referência, então não aponta para nenhum objeto.


- Tipos primitivos são tipos valor
Em Java, tipos primitivos são tipos valor. Tipos valor são CAIXAS e não ponteiros.

Exemplo:

double x, y;  (x e y são criados em memoria > stack)

x = 10; => o valor 10 será armazenado ainda em memoria > stack, na "caixa" x
y = x; => y recebe uma cópia de x, ainda em memoria > stack, na "caixa" y


- Tipos primitivos e inicialização

Exemplo:

int p;
System.out.println(p); // erro: varivável não iniciada

p = 10;;
System.out.println(p);


- Valores padrão
Quando alocamos (new) qualquer tipo estruturado (classe ou array), são atribuidos valores padrão aos seus elementos: números = 0, boolean = false, char = carctere código 0, objeto = null


*Desalocação de memória - garbage collector e escopo local

- Garbage collector
É um processo que automatiza o gerenciamento de memoria de um prorama em execução (heap)
Ele monitora objetos alocados dinamicamente pelo programa (no heap), desalocando aqueles que não estão mais sendo utilizados.
Objetos alocados dinamicamente, quando não possuem referência para eles serão desalocados pelo garbage collector em um futuro próximo

- Desalocação por escopo
Se tipos primitivos, é criado escopo dentro da stack (por métdos, if, etc), podendo existir escopo dentro de escopo. Assim que o escopo é finalizado, ele deixa de existir na stack e consequentemente também a variável deixa de existir na stack.
Variáveis locais são desalocadas imediatamente assim que seu escopo local sai de execução


*Vetores
- Revisão de conceito de vetor
- Declaração e instanciação
- Manipulação de vetor de elementos tipo valor (tipo primitivo)
- Manipulação de vetor de elementos tipo referência (classe)
- Acesso aos elementos
- Propriedade length

Em programação, "vetor" é o nome dado a arranjos unidimensionais.
Arranjo (array) é uma estrutura de dados: Homogênea (dados do mesmo tipo), Ordenada (elementos acessados por meio de posições) e Alocada de uma vez só, em um bloco contíguo de memória.
Vantagens: acesso imediato aos elementos pela sua posição.
Desvantagens: tamanho fixo, dificuldade para se realizar inserções e deleções.

Problema exemplo 1 - vetor tipo valor (tipo primitivo)
Fazer um programa para ler um número inteiro N e a altura de N pessoas. Armazene as N alturas em um vetor. Em seguida, mostrar a altura média dessas pessoas. => a variavel N, na stack, armazenará o numero int N, a variavel vect será ponteiro para os vetores, e os vetores, no heap, armazenarão os números do tipo double digitados no laço for, sendo os vetores do tipo valor (primitivo)

Problema exemplo 2 
Fazer um programa para ler um número inteiro N e os dados (nome e preço) de N produtos. Armazene os N produtos em um vetor. Em seguida, mostrar preço médio dos produtos. => a variavel N, na stack, armazenará o numero int N, a variavel vect será ponteiro para os vetores, e os vetores, no heap, serão inicialmente criados nulos por valor padrão, e serão ponteiros para um objeto que instanciam a classe Product durante o laço for, sendo os vetores então do tipo referência (classe)

- Prefira utilizar "length" em um laço for para vetores, afim que não depender da primeira variável 'n':

	int n = sc.nextInt();		
	Product[] vect = new Product[n];
		
	for(int i = 0; i < vect.length; i++) {}

*Boxing, unboxing, wrapper classes

- Boxing é o processo de conversão de um objeto tipo valor para um objeto tipo referência compatível

int x = 20;
Object obj = x;

Object é a classe mais genérica do Java, todas as classes por padrão são 'filhas' dessa classe object. No caso acima, x passa a ser do tipo object e será alocado um objeto no heap contendo o valor 20 e a varável obj será ponteiro para essa alocação.

- Unboxing é o processo de conversão de um objeto tipo referência para um objeto tipo valor compatível

int y = (int) obj;

Será criada no stack uma alocação y tipo valor com valor 20

- Wrapper classes
São classes equivalentes aos tipos primitivos, para que boxing e unboxing seja feito de forma natural na linguagem. Para cada tipo primitivo, ele tem um tipo classe compatível com o mesmo tipo - Exemplo: 
int(primitivo) = Integer(classe), boolean(primitivo) = Boolean(classe), char(primitivo) = Character(classe), byte(primitivo) = Byte(classe). 
Elas tem o objetivo de tratar os tipos primitivos como classes, de forma transparente ao compilador, evitando conversões e castings.
Uso comum de wrapper classes: campos de entidade em sistemas de informação (IMPORTANTE!) - pois tipos referência (classes) aceitam valor null e usufruem dos recursos OO

Sem wrapper class
int x = 20;
Object obj = x;
int y = (int) obj;

Com wrapper class
int x = 20;
Integer obj = x;
int y = obj;

Utilizar em atributos de classes e declaração de variáveis

*Laço "for each"
Sintaxe opcional e simplificada para percorrer coleções

Sintaxe:
for (Tipo apelido : coleção){
	<comando 1>
	<comando 2>
}

*Listas
- Conceito de lista: é uma estrutura de dados homogênea (dados do mesmo tipo), ordenada (elementos acessados por meio de posições), inicia vazia, e seus elementos sãoa locados sob demanda, cada elemento ocupa um "nó" (ou nodo) da lista
- Tipo (interface): List (! não é classe, é interface) - interface é um tipo que define apenas as especificações das operações.
- Classes que implementam: ArrayList(mistura de vetor e lista), LinkedList, etc. - utilizadas para implementar a interface List, pois ela sozinha não pode ser implementada pois não é classe.
- Vantagens: tamanho variável, facilidade para se realizar inserções e deleções
- Desvantagens: acesso sequencial aos elementos* - dependendo da implementação da lista, a navegação é otimizada, como é o caso de ArrayList
Demo:
- Tamanho da lista: size()
- Inserir elemento na lista: add(obj), add(int, obj)
- Remover elementos da lista: remove(obj), remove(int), removeIf(Predicate)
- Encontrar posição de elemento: indexOf(obj), lastIndexOf(obj)
- Filtrar lista com base em predicado: List<Integer> result = list.stream().filter(x -> x > 4).collect(Collectors.toList());
- Encontrar primeira ocorrência com base em predicado: Integer result = list.stream().filter(x -> x > 4).findFirst().orElse(null);

- Assuntos pendentes: interfaces, generics, predicados (lambda)

*Matrizes

- Conceito de matriz: nome dado a arranjos (array) bidimensionais - linhas (1º indice) e colunas (2º indice) - (ao contrário do vetor, que seria um arranjo unidimensional) - "vetor de vetores"; Assim como todo array, ele é uma estrutura de dados homogênea, ordenada e é alocada de uma vez só, em um bloco contíguo de memória.
- Vantagens: acesso imediato aos elementos pela sua posição.
- Desvantagens: tamanho fixo e dificuldade para se realizar inserções e deleções
- Declaração e instanciação
- Acesso aos elementos / como percorrer uma matriz
- Propriedade length


--------------------------------------------------------
-- Tópicos essenciais em Java--

*Introdução a data-hora e duração

Conceitos importantes:
- Data-[hora] local:ano-mês-dia-[hora] sem fuso horário; [hora] opcional
- Data-hora global: ano-mês-dia-hora com fuso horário
- Duração: tempo decorrido entre duas data-horas

* Timezone (fuso horário)
- GMT - Greenwich Mean Time
• Horário de Londres
• Horário do padrão UTC - Coordinated Universal Time
• Também chamado de "Z" time, ou Zulu time

- Outros fuso horários são relativos ao GMT/UTC:
• São Paulo: GMT-3
• Manaus: GMT-4
• Portugal: GMT+1

- Muitas linguagens/tecnologias usam nomes para as timezones:
• "US/Pacific"
• "America/Sao_Paulo"

*Padrão ISO 8601

Data-[hora] local:
	2022-07-21
	2022-07-21T14:52
	2022-07-22T14:52:09
	2022-07-22T14:52:09.4073

Data-hora global:
	2022-07-23T14:52:09Z
	2022-07-23T14:52:09.254935Z
	2022-07-23T14:52:09-03:00


*Operações importantes com data-hora

- Instanciação
	• (agora) ➞ Data-hora
	• Texto ISO 8601 ➞ Data-hora
	• Texto formato customizado ➞ Data-hora
	• dia, mês, ano, [horário] ➞ Data-hora local

- Formatação
	• Data-hora ➞ Texto ISO 8601
	• Data-hora ➞ Texto formato customizado

- Converter data-hora global para local
	• Data-hora global, timezone (sistema local) ➞ Data-hora local

- Obter dados de uma data-hora local
	• Data-hora local ➞ dia, mês, ano, horário

- Cálculos com data-hora
	• Data-hora +/- tempo ➞ Data-hora
	• Data-hora 1, Data-hora 2 ➞ Duração


*Principais tipos Java (versão 8+)

- Data-hora local
	• LocalDate
	• LocalDateTime
- Data-hora global
	• Instant
- Duração
	• Duration
- Outros
	• Zoneld
	• ChronoUnit